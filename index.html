<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Idle Souls-RPG (Idle SoulsLike)</title>
<style>
  :root{--bg:#0b0b0f;--card:#121217;--accent:#d6b370;--muted:#9aa0a6;--good:#6ad06a}
  body{margin:0;font-family:Inter,Segoe UI,Arial;background:linear-gradient(180deg,#06060a, #0b0b0f);color:#e6e6e6}
  .wrap{max-width:980px;margin:18px auto;padding:18px;display:grid;grid-template-columns:360px 1fr;gap:18px}
  .card{background:var(--card);border-radius:10px;padding:12px;box-shadow:0 6px 24px rgba(0,0,0,.6)}
  h1{margin:0 0 12px;font-size:20px;color:var(--accent)}
  small{color:#9aa0a6}
  .stats p{margin:6px 0}
  .attr-row{display:flex;gap:6px;align-items:center;margin:6px 0}
  .attr-row button{padding:4px 8px;border-radius:6px;border:none;background:#1b1b1f;color:#fff;cursor:pointer}
  button.shop{background:linear-gradient(90deg,#2a6bd6,#2a9ad6);border:none;padding:8px;border-radius:6px;color:#fff;cursor:pointer}
  .log{height:180px;overflow:auto;background:#0d0d0f;padding:8px;border-radius:6px;font-size:13px;color:#cfcfcf}
  .controls{display:flex;gap:8px;margin-top:8px}
  .area{display:flex;flex-direction:column;gap:6px}
  .bar{height:14px;background:#0f0f11;border-radius:6px;overflow:hidden}
  .bar > i{display:block;height:100%;background:linear-gradient(90deg,#d65b5b,#d6b370);width:0%}
  .small{font-size:13px;color:#9aa0a6}
  .shop-item{display:flex;justify-content:space-between;align-items:center;padding:8px;border-radius:6px;background:#0f1013;margin-bottom:6px}
  .muted{color:#9aa0a6}
  .spells{display:flex;flex-direction:column;gap:6px;margin-top:8px}
  .top-controls{display:flex;gap:8px;align-items:center;margin-bottom:8px}
  input.name-input{background:#0f0f11;border:1px solid #222;padding:6px;border-radius:6px;color:#fff}
  .tiny{font-size:12px;padding:6px;border-radius:6px}
  /* Estilo para mostrar poções nos botões */
  .potion-btn-wrap{position:relative; display:inline-block;}
  .potion-count{position:absolute; top:-8px; right:-8px; background:var(--accent); color:#000; font-size:10px; padding:2px 5px; border-radius:50%; line-height:1}
</style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <div class="top-controls">
      <div style="flex:1">
        <h1>Idle SoulsLike - Hero</h1>
        <small class="muted"> (Idle RPG)</small>
      </div>
      <div id="nameControls" style="text-align:right">
        <input id="nameInput" class="name-input" placeholder="Wanderer" />
        <button class="tiny" onclick="setNameFromInput()">Set Name</button>
        <button class="tiny" onclick="resetSave()">Reset Save</button>
      </div>
    </div>

    <div class="stats">
      <p><strong id="hero-name">Wanderer</strong></p>
      <p>Level: <strong id="level">1</strong> / 200 &nbsp; • &nbsp; Unspent Points: <strong id="unspent">0</strong></p>
      <p>XP: <span id="xp">0</span> / <span id="xpNeeded">50</span></p>
      <div class="bar" title="XP bar"><i id="xpbar" style="width:0%"></i></div>

      <p>HP: <strong id="hp">100</strong> / <strong id="maxHp">100</strong></p>
      <div class="bar" title="HP"><i id="hpbar" style="width:100%"></i></div>

      <p>MP: <strong id="mp">30</strong> / <strong id="maxMp">30</strong></p>
      <div class="bar" title="MP"><i id="mpbar" style="width:100%"></i></div>

      <p>Attack: <strong id="atk">10</strong> &nbsp; • &nbsp; Defense: <strong id="def">5</strong></p>
      <p>Attack Interval: <strong id="atkInterval">2.0</strong>s</p>
      <p>Gold: <strong id="gold">0</strong> &nbsp; • &nbsp; Area: <strong id="area">1</strong> / 300</p>
      <p class="small">Monsters defeated in area: <span id="areaKills">0</span> / 10</p>
    </div>

    <hr style="border:none;height:1px;background:#0e0e11;margin:12px 0">

    <div>
      <p class="small">Attributes (3 points per level)</p>
      <div class="attr-row"><div style="flex:1"><b>Strength</b><div class="small">Damage</div></div><div><span id="str">1</span></div><div><button onclick="alloc('str')">+1</button></div></div>
      <div class="attr-row"><div style="flex:1"><b>Agility</b><div class="small">Attack speed</div></div><div><span id="agi">1</span></div><div><button onclick="alloc('agi')">+1</button></div></div>
      <div class="attr-row"><div style="flex:1"><b>Vitality</b><div class="small">HP & defense</div></div><div><span id="vit">1</span></div><div><button onclick="alloc('vit')">+1</button></div></div>
      <div class="attr-row"><div style="flex:1"><b>Intelligence</b><div class="small">MP & spells</div></div><div><span id="int">1</span></div><div><button onclick="alloc('int')">+1</button></div></div>
      <div class="attr-row"><div style="flex:1"><b>Dexterity</b><div class="small">Hit chance & crit</div></div><div><span id="dex">1</span></div><div><button onclick="alloc('dex')">+1</button></div></div>
    </div>

    <div style="margin-top:10px">
      <button class="shop" onclick="resetAllocation()">Reset Alloc (<span id="respecCost">5000</span>g)</button>
    </div>

    <hr style="border:none;height:1px;background:#0e0e11;margin:12px 0">

    <h3 style="margin:6px 0">Shop</h3>
    <div id="shop" style="max-height:320px;overflow:auto">
      </div>
  </div>

  <div class="card">
    <h1>Area & Combat</h1>
    <div class="area">
      <p><strong id="enemyName">Weak Slime</strong> <small class="muted" id="enemyType"> (Monster)</small></p>
      <p>Enemy HP: <strong id="enemyHp">30</strong> / <strong id="enemyMaxHp">30</strong></p>
      <div class="bar"><i id="enemyHpbar" style="width:100%"></i></div>

      <p class="small">Enemy Attack: <span id="enemyAtk">5</span> &nbsp; • &nbsp; Hit Chance: <span id="enemyHit">85</span>%</p>
      <p class="small">Attack Interval: <span id="enemyInterval">2.5</span>s</p>

      <div class="controls">
        <div class="potion-btn-wrap">
          <button onclick="usePotion('hp')">Use HP Potion</button>
          <span class="potion-count" id="hpPotCount">0</span>
        </div>
        <div class="potion-btn-wrap">
          <button onclick="usePotion('mp')">Use MP Potion</button>
          <span class="potion-count" id="mpPotCount">0</span>
        </div>
        <button onclick="openShopPrompt()">Open Shop</button>
      </div>

      <div style="margin-top:10px">
        <h3 style="margin:6px 0">Spells</h3>
        <div class="spells" id="spellsList">
          <div class="small muted">No spells purchased.</div>
        </div>
      </div>

      <hr style="border:none;height:1px;background:#0e0e11;margin:12px 0">
      <div class="log" id="log"></div>
    </div>
  </div>
</div>

<script>
/* =========================
    GAME CONFIG / BALANCE
    ========================= */
const SAVE_KEY = 'idleSoulsSaveV1';
const MAX_LEVEL = 200;
const AREAS_TOTAL = 300;
const MONSTERS_PER_AREA = 10;
const ATTR_PER_LEVEL = 3;
const BASE_XP_REQ = 50;
const BASE_GOLD = 5;
const AUTOSAVE_INTERVAL_MS = 5000;
const HP_MP_RECOVERY_PCT = 0.20; 
const INITIAL_RESPEC_COST = 5000; 

// Array com nomes de monstros e chefes para áreas específicas
const MONSTERS_DATA = [
    {area: 1, monster: "Slime", boss: "Slime King"},
    {area: 2, monster: "Common Bat", boss: "Vamprick"},
    {area: 3, monster: "Sewer Rat", boss: "Plague Master"},
    {area: 4, monster: "Blood Mosquito", boss: "Dengue Queen"},
    {area: 5, monster: "Mutant Grasshopper", boss: "Prime Swarm"},
    // Adicione mais áreas aqui conforme o desenvolvimento
];
const DEFAULT_MONSTERS = ["Slime", "Goblin", "Wolf", "Bandit", "Skeleton", "Gargoyle", "Cultist", "Warden", "Hollow", "Shade"];

const SHOP_BASE = {
  hpPot: {name:"HP Potion", basePrice:100, action:"hpPotion"}, 
  mpPot: {name:"MP Potion", basePrice:100, action:"mpPotion"}, 
  weapon: {name:"Weapon Upgrade (+atk)", basePrice:1000, action:"weaponUp"}, 
  armor: {name:"Armor Upgrade (+def)", basePrice:1000, action:"armorUp"}, 
  spell: {name:"Learn Fireball", basePrice:10000, action:"learnSpell"} 
};

/* =========================
    HERO STATE
    ========================= */
let hero = {
  name:"Wanderer",
  level:1,
  xp:0,
  gold:0,
  unspent:0,
  attr:{ str:1, agi:1, vit:1, int:1, dex:1 },
  baseAtk:10,
  baseDef:5,
  baseHp:100,
  baseMp:30,
  atkBonus:0,
  defBonus:0,
  potions:{hp:2, mp:1},
  spells:[], 
  purchases: { hpPot:0, mpPot:0, weapon:0, armor:0, spell:0 },
  respecCost: INITIAL_RESPEC_COST 
};

function recalcDerived() {
  const A = hero.attr;
  hero.maxHp = hero.baseHp + (A.vit * 10) + (hero.level * 2) + (hero.defBonus * 2);
  hero.maxMp = hero.baseMp + (A.int * 6) + Math.floor(hero.level/2);
  hero.atk = hero.baseAtk + Math.floor(A.str * 2) + hero.atkBonus;
  
  // Defesa com 0.1 por ponto de Vit
  hero.def = hero.baseDef + (A.vit * 0.1) + hero.defBonus;
  
  // Attack Interval ajustado para Agility (1 Agi=3.5s, 300 Agi=0.5s)
  const agiReduction = (A.agi - 1) * 0.01003;
  hero.attackInterval = Math.max(0.5, 3.5 - agiReduction); 
  
  hero.hitChance = Math.min(98, 70 + A.dex * 1.2); 
  
  if (!hero.hp || hero.hp > hero.maxHp) hero.hp = hero.maxHp;
  if (!hero.mp || hero.mp > hero.maxMp) hero.mp = hero.maxMp;
}

/* =========================
    AREA / ENEMY STATE
    ========================= */
let area = 1;
let areaKills = 0; // Contagem de 0 (monstro 1) a 9 (monstro 10). 10 = Boss
let isBossFight = false;
let enemy = {}; 

/* =========================
    HELPER: difficulty curve & spawn
    ========================= */
function areaGoldMultiplier(a){
  if (a <=1) return 1;
  return 1 + (a-1) * (99 / (AREAS_TOTAL - 1)); 
}

function generateEnemy(isBoss=false){
  const a = area;
  const lvl = hero.level;
  
  // Nível do monstro é baseado na contagem de mortes na área (1 a 10)
  const monsterLevel = isBoss ? MONSTERS_PER_AREA : areaKills + 1;
  
  let difficultyFactor;
  if (lvl <= 150) {
    difficultyFactor = 1 + (lvl-1) * 0.018 + (a-1)*0.006;
  } else {
    difficultyFactor = 1 + (150-1) * 0.018 + (lvl-150) * 0.07 + (a-1)*0.01;
  }
  
  // **NOVO AUMENTO DE HP E ATK COM BASE NO NÍVEL DO MONSTRO NA ÁREA**
  const hpScaling = monsterLevel * 2.5; 
  const atkScaling = monsterLevel * 0.5;

  const baseHp = Math.floor(20 + a * 6 + lvl * 4 + hpScaling) * difficultyFactor;
  const baseAtk = Math.floor(3 + a * 1.5 + lvl * 0.7 + atkScaling) * difficultyFactor;
  
  // Hit Chance do inimigo diminuída pela defesa do herói
  const defReduction = hero.def * 0.35; 
  const baseHit = 65 + Math.floor(a*0.05); 
  const hit = Math.max(20, Math.floor(baseHit - defReduction));

  const interval = Math.max(0.6, 2.5 - (a*0.002) - (lvl*0.01));

  // Escolhe o nome do monstro/chefe
  let monsterName;
  let bossName;
  const customData = MONSTERS_DATA.find(data => data.area === a);
  if (customData) {
      monsterName = customData.monster;
      bossName = customData.boss;
  } else {
      // Usa os nomes padrão se a área não estiver na lista personalizada
      monsterName = DEFAULT_MONSTERS[Math.floor(a/30)%DEFAULT_MONSTERS.length];
      bossName = `${monsterName} King`; 
  }

  if (isBoss) {
    return {
      name: bossName,
      // Boss mantém alto multiplicador de HP para ser desafiador
      hp: Math.floor(baseHp * 5.5),
      maxHp: Math.floor(baseHp * 5.5),
      atk: Math.max(5, Math.floor(baseAtk * 1.6)),
      hit: Math.min(98, Math.floor(hit * 1.05)), 
      interval: Math.max(0.8, interval * 0.9),
      goldReward: Math.floor((BASE_GOLD * areaGoldMultiplier(a)) * 8)
    };
  } else {
    return {
      // Nome do monstro inclui o nível atual (Ex: Slime Lv1)
      name:`${monsterName} Lv${monsterLevel}`,
      hp: Math.floor(baseHp),
      maxHp: Math.floor(baseHp),
      atk: Math.max(1, Math.floor(baseAtk)),
      hit: Math.max(20, Math.floor(hit)), 
      interval: Math.max(0.6, interval),
      goldReward: Math.floor(BASE_GOLD * areaGoldMultiplier(a) * (1 + Math.random()*0.4))
    };
  }
}

/* =========================
    XP and Leveling
    ========================= */
function xpNeededFor(level){
  return Math.floor(BASE_XP_REQ * Math.pow(level, 1.12));
}

function gainXP(amount){
  hero.xp += amount;
  log(`Gained ${amount} XP.`);
  while (hero.level < MAX_LEVEL && hero.xp >= xpNeededFor(hero.level)){
    hero.xp -= xpNeededFor(hero.level);
    hero.level++;
    hero.unspent += ATTR_PER_LEVEL;
    hero.baseHp += 8;
    hero.baseMp += 3;
    log(`Leveled up! You are now level ${hero.level}. +${ATTR_PER_LEVEL} attribute points.`);
    if (hero.level >= MAX_LEVEL){
      hero.xp = Math.min(hero.xp, xpNeededFor(hero.level)-1);
      break;
    }
  }
  recalcDerived();
  updateUI();
}

/* =========================
    COMBAT LOGIC
    ========================= */
let autoAttackTimer = null;
let enemyAttackTimer = null;

function startCombat(){
  stopCombat();
  enemyAttackTimer = setInterval(() => {
    if (!enemy || enemy.hp <= 0) return;
    if (Math.random()*100 <= enemy.hit){
      const raw = enemy.atk;
      const mitig = Math.floor(hero.def * 0.7);
      const dmg = Math.max(1, Math.floor(raw - mitig));
      hero.hp -= dmg;
      log(`Enemy hits you for ${dmg} damage.`);
      if (hero.hp <= 0){
        hero.hp = 0;
        log("You died! Area will restart.");
        onHeroDeath();
      }
      updateUI();
    } else {
      log("Enemy missed!");
    }
  }, Math.max(250, Math.floor(enemy.interval * 1000)));

  autoAttackTimer = setInterval(() => {
    if (!enemy || enemy.hp <= 0) return;
    heroAutoAttack();
  }, Math.max(150, Math.floor(hero.attackInterval * 1000)));
}

function stopCombat(){
  if (autoAttackTimer) { clearInterval(autoAttackTimer); autoAttackTimer = null; }
  if (enemyAttackTimer) { clearInterval(enemyAttackTimer); enemyAttackTimer = null; }
}

function heroAutoAttack(){
  if (hero.hp <= 0 || !enemy) return;
  if (Math.random()*100 <= hero.hitChance){
    const crit = Math.random() < Math.min(0.25, hero.attr.dex * 0.0025);
    const baseDmg = hero.atk + Math.floor(hero.attr.str * 1.5);
    const dmg = Math.max(1, Math.floor(baseDmg * (crit?1.8:1)));
    enemy.hp -= dmg;
    log(`You hit ${enemy.name} for ${dmg}${crit ? ' (CRIT!)' : ''}.`);
    if (enemy.hp <= 0){
      enemy.hp = 0;
      onEnemyDefeated();
    }
    updateUI();
  } else {
    log("You missed the attack!");
  }
}

/* =========================
    ON ENEMY / BOSS DEFEAT
    ========================= */
function onEnemyDefeated(){
  stopCombat();
  const gold = Math.max(0, Math.floor(enemy.goldReward));
  hero.gold += gold;
  log(`Defeated ${enemy.name}. Gained ${gold} gold.`);
  const xpGain = Math.max(5, Math.floor((enemy.maxHp/10) * (isBossFight ? 2.5 : 1)));
  gainXP(xpGain);

  if (isBossFight){
    log(`Boss defeated! You advance from Area ${area} to Area ${Math.min(AREAS_TOTAL, area+1)}.`);
    area = Math.min(AREAS_TOTAL, area+1);
    areaKills = 0; // Reseta para o monstro 1 (areaKills=0)
    isBossFight = false;
    spawnEnemy();
    updateUI();
    startCombat();
  } else {
    areaKills++; // Passa para o próximo nível de monstro (ex: de 0 para 1, ou seja, Lv1 para Lv2)
    if (areaKills >= MONSTERS_PER_AREA){
      isBossFight = true;
      spawnEnemy(true);
      updateUI();
      startCombat();
    } else {
      spawnEnemy(false);
      startCombat();
    }
  }
}

/* =========================
    HERO DEATH: restart area
    ========================= */
function onHeroDeath(){
  stopCombat();
  areaKills = 0; // Recomeça do monstro 1
  isBossFight = false;
  recalcDerived();
  hero.hp = hero.maxHp;
  hero.mp = hero.maxMp;
  spawnEnemy();
  updateUI();
  startCombat();
}

/* =========================
    SPAWN ENEMY
    ========================= */
function spawnEnemy(boss=false){
  enemy = generateEnemy(boss);
  isBossFight = !!boss;
  updateUI();
}

/* =========================
    SHOP / ITEMS
    ========================= */
function shopPrice(key){
  const base = SHOP_BASE[key].basePrice;
  const count = hero.purchases[key] || 0;
  if (key === 'weapon' || key === 'armor') {
    // Aumento de preço para armas e armaduras
    return Math.floor(base * Math.pow(1.18, count));
  } else if (key === 'hpPot' || key === 'mpPot') {
    // Aumento de preço para poções
    return Math.floor(base * Math.pow(1.10, count));
  } else if (key === 'spell') {
      return base; // Preço fixo para Fireball
  }
  return base;
}

function buyItem(key){
  // Lógica especial para Fireball: só pode comprar uma vez
  if (key === 'spell' && hero.spells.length > 0) {
      log("You already know Fireball.");
      return;
  }

  const price = shopPrice(key);
  if (hero.gold < price){
    log("Not enough gold.");
    return;
  }
  hero.gold -= price;
  hero.purchases[key] = (hero.purchases[key]||0) + 1;
  
  if (key === 'hpPot'){
    hero.potions.hp += 1;
    log("Bought HP Potion.");
  } else if (key === 'mpPot'){
    hero.potions.mp += 1;
    log("Bought MP Potion.");
  } else if (key === 'weapon'){
    hero.atkBonus += 3 + Math.floor(hero.purchases.weapon * 1.2);
    log("Weapon upgraded. Attack increased.");
  } else if (key === 'armor'){
    hero.defBonus += 2 + Math.floor(hero.purchases.armor * 1.1);
    log("Armor upgraded. Defense increased.");
  } else if (key === 'spell'){
    hero.spells.push({id:Date.now(), name:"Fireball", mpCost:8, power: Math.floor(30 + area * 1.5 + hero.level * 0.8)});
    log("You learned Fireball.");
  }
  recalcDerived();
  updateUI();
}

/* =========================
    POTIONS / SPELLS USE
    ========================= */
function usePotion(type){
  if (type==='hp'){
    if (hero.potions.hp <= 0){ log("No HP potions."); return; }
    hero.potions.hp--;
    // Recupera 20% do HP máximo
    const heal = Math.floor(hero.maxHp * HP_MP_RECOVERY_PCT);
    hero.hp = Math.min(hero.maxHp, hero.hp + heal);
    log(`Used HP potion. Restored ${heal} HP.`);
    updateUI();
  } else {
    if (hero.potions.mp <= 0){ log("No MP potions."); return; }
    hero.potions.mp--;
    // Recupera 20% do MP máximo
    const regen = Math.floor(hero.maxMp * HP_MP_RECOVERY_PCT);
    hero.mp = Math.min(hero.maxMp, hero.mp + regen);
    log(`Used MP potion. Restored ${regen} MP.`);
    updateUI();
  }
}

function castSpell(spellIndex){
  const spell = hero.spells[spellIndex];
  if (!spell){ log("No such spell."); return; }
  if (hero.mp < spell.mpCost){ log("Not enough MP."); return; }
  if (!enemy || enemy.hp <= 0) { log("No target."); return; }
  hero.mp -= spell.mpCost;
  const power = Math.floor(spell.power + hero.attr.int * 2 + hero.level * 0.6);
  enemy.hp -= power;
  log(`Cast ${spell.name} for ${power} damage.`);
  if (enemy.hp <= 0) onEnemyDefeated();
  updateUI();
}

/* =========================
    ATTR ALLOCATION
    ========================= */
function alloc(which){
  if (hero.unspent <= 0){ log("No attribute points."); return; }
  hero.attr[which] += 1;
  hero.unspent -= 1;
  recalcDerived();
  updateUI();
  log(`+1 ${which.toUpperCase()}`);
}

function resetAllocation(){
  const cost = hero.respecCost;
  if (hero.gold < cost) {
    log(`Not enough gold to respec. Need ${cost}g.`);
    return;
  }

  if (!confirm(`Reset attributes for ${cost} gold? The next cost will be ${cost * 2} gold.`)) {
    return;
  }
  
  hero.gold -= cost;
  // Dobra o custo do respec
  hero.respecCost = cost * 2; 

  const fromLevels = (hero.level - 1) * ATTR_PER_LEVEL;
  hero.attr = {str:1, agi:1, vit:1, int:1, dex:1};
  hero.unspent = fromLevels;
  recalcDerived();
  updateUI();
  log(`Attributes reset. All points refunded. Next respec cost: ${hero.respecCost}g.`);
}

/* =========================
    UI UPDATE & LOG
    ========================= */
const logDiv = document.getElementById('log');
function log(text){
  const time = new Date().toLocaleTimeString();
  logDiv.innerHTML = `<div style="margin-bottom:6px"><small class="muted">[${time}]</small> ${escapeHtml(text)}</div>` + logDiv.innerHTML;
  if (logDiv.childElementCount > 200) logDiv.removeChild(logDiv.lastChild);
}
function escapeHtml(s){ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;'); }

function toggleNameInput(show) {
  const nameControls = document.getElementById('nameControls');
  nameControls.style.display = show ? 'block' : 'none';
}

function updateUI(){
  document.getElementById('hero-name').innerText = hero.name;
  
  // Esconde o input e botão se o nome for diferente do padrão "Wanderer"
  const isDefaultName = hero.name === "Wanderer";
  if (isDefaultName) {
      document.getElementById('nameInput').placeholder = hero.name;
  }
  toggleNameInput(isDefaultName);


  document.getElementById('level').innerText = hero.level;
  document.getElementById('unspent').innerText = hero.unspent;
  document.getElementById('xp').innerText = Math.floor(hero.xp);
  document.getElementById('xpNeeded').innerText = xpNeededFor(hero.level);
  const xpPct = Math.min(100, Math.floor((hero.xp / xpNeededFor(hero.level)) * 100));
  document.getElementById('xpbar').style.width = xpPct + '%';

  document.getElementById('hp').innerText = Math.floor(hero.hp);
  document.getElementById('maxHp').innerText = Math.floor(hero.maxHp);
  document.getElementById('hpbar').style.width = Math.floor((hero.hp/hero.maxHp)*100) + '%';

  document.getElementById('mp').innerText = Math.floor(hero.mp);
  document.getElementById('maxMp').innerText = Math.floor(hero.maxMp);
  document.getElementById('mpbar').style.width = Math.floor((hero.mp/hero.maxMp)*100) + '%';

  document.getElementById('atk').innerText = Math.floor(hero.atk);
  document.getElementById('def').innerText = hero.def.toFixed(1); 
  document.getElementById('atkInterval').innerText = hero.attackInterval.toFixed(2);
  document.getElementById('gold').innerText = Math.floor(hero.gold);

  document.getElementById('str').innerText = hero.attr.str;
  document.getElementById('agi').innerText = hero.attr.agi;
  document.getElementById('vit').innerText = hero.attr.vit;
  document.getElementById('int').innerText = hero.attr.int;
  document.getElementById('dex').innerText = hero.attr.dex;

  document.getElementById('area').innerText = area;
  // Agora mostra a contagem correta (1 a 10)
  document.getElementById('areaKills').innerText = isBossFight ? 10 : areaKills + 1; 
  document.getElementById('respecCost').innerText = hero.respecCost; 

  // Poções nos botões
  document.getElementById('hpPotCount').innerText = hero.potions.hp;
  document.getElementById('mpPotCount').innerText = hero.potions.mp;

  if (enemy){
    document.getElementById('enemyName').innerText = enemy.name;
    document.getElementById('enemyType').innerText = isBossFight ? " (BOSS)" : " (Monster)";
    document.getElementById('enemyHp').innerText = Math.max(0, Math.floor(enemy.hp));
    document.getElementById('enemyMaxHp').innerText = Math.floor(enemy.maxHp);
    document.getElementById('enemyHpbar').style.width = Math.floor(Math.max(0, enemy.hp / enemy.maxHp * 100)) + '%';
    document.getElementById('enemyAtk').innerText = Math.floor(enemy.atk);
    document.getElementById('enemyHit').innerText = Math.floor(enemy.hit);
    document.getElementById('enemyInterval').innerText = (enemy.interval).toFixed(2);
  }
  renderShop();
  renderSpells();
}

function renderShop(){
  const shopDiv = document.getElementById('shop');
  shopDiv.innerHTML = '';
  
  for (const key of Object.keys(SHOP_BASE)){
    // Lógica para esconder Fireball após a compra
    if (key === 'spell' && hero.spells.length > 0) {
        continue;
    }
    
    const info = SHOP_BASE[key];
    const price = shopPrice(key);
    const el = document.createElement('div');
    el.className = 'shop-item';
    el.innerHTML = `<div>
      <div style="font-weight:600">${info.name}</div>
      <div class="small muted">Owned: ${hero.purchases[key]||0}</div>
    </div>
    <div style="text-align:right">
      <div style="font-weight:700">${price}g</div>
      <div style="margin-top:6px"><button onclick="buyItem('${key}')" class="shop">Buy</button></div>
    </div>`;
    shopDiv.appendChild(el);
  }
  const potInfo = document.createElement('div');
  potInfo.style.marginTop='10px';
  potInfo.innerHTML = `<div class="small muted">Potions: HP ${hero.potions.hp} • MP ${hero.potions.mp}</div>
  <div class="small muted">Spells owned: ${hero.spells.length}</div>`;
  shopDiv.appendChild(potInfo);
}

function renderSpells(){
  const sdiv = document.getElementById('spellsList');
  sdiv.innerHTML = '';
  if (hero.spells.length === 0) {
    sdiv.innerHTML = '<div class="small muted">No spells purchased.</div>';
    return;
  }
  hero.spells.forEach((s,i) => {
    const node = document.createElement('div');
    node.className='shop-item';
    node.innerHTML = `<div>
      <div style="font-weight:600">${s.name}</div>
      <div class="small muted">MP: ${s.mpCost} • Power: ${s.power}</div>
    </div>
    <div><button onclick="castSpell(${i})" class="shop">Cast</button></div>`;
    sdiv.appendChild(node);
  });
}

/* =========================
    SAVE / LOAD (localStorage)
    ========================= */
function saveGame(){
  try {
    const save = {
      hero: hero,
      area: area,
      areaKills: areaKills,
      isBossFight: isBossFight,
      enemy: enemy
    };
    localStorage.setItem(SAVE_KEY, JSON.stringify(save));
  } catch (e) {
    console.warn('Save failed', e);
  }
}

function loadGame(){
  try {
    const raw = localStorage.getItem(SAVE_KEY);
    if (!raw) return false;
    const data = JSON.parse(raw);
    if (!data || !data.hero) return false;
    
    hero = data.hero;
    // Adiciona respecCost se não existir (para saves antigos)
    if (typeof hero.respecCost === 'undefined') {
        hero.respecCost = INITIAL_RESPEC_COST;
    }
    
    area = data.area || 1;
    areaKills = data.areaKills || 0;
    isBossFight = !!data.isBossFight;
    enemy = data.enemy || generateEnemy(isBossFight);
    recalcDerived();
    updateUI();
    log(`Loaded save for ${hero.name} — Area ${area}`);
    return true;
  } catch (e) {
    console.warn('Load failed', e);
    return false;
  }
}

function resetSave(){
  if (confirm('Reset save? This will erase your progress.')) {
    localStorage.removeItem(SAVE_KEY);
    // reset to defaults
    hero = {
      name:"Wanderer",
      level:1,xp:0,gold:0,unspent:0,
      attr:{ str:1, agi:1, vit:1, int:1, dex:1 },
      baseAtk:10,baseDef:5,baseHp:100,baseMp:30,atkBonus:0,defBonus:0,
      potions:{hp:2, mp:1},spells:[],purchases:{ hpPot:0, mpPot:0, weapon:0, armor:0, spell:0 },
      respecCost: INITIAL_RESPEC_COST
    };
    area = 1; areaKills = 0; isBossFight = false;
    // Garante que o input reaparece ao resetar
    document.getElementById('nameInput').value = "";
    toggleNameInput(true); 

    recalcDerived();
    spawnEnemy(false);
    updateUI();
    saveGame();
    log('Save reset. New game started.');
  }
}

/* =========================
    INIT / START
    ========================= */
function init() {
  const loaded = loadGame();
  if (!loaded){
    recalcDerived();
    spawnEnemy(false);
    updateUI();
    log("No save found — start a new game. Use the input above to set your name.");
    saveGame();
  }
  startCombat();
  setInterval(saveGame, AUTOSAVE_INTERVAL_MS); 
  // Usa hero.name para a mensagem final
  log(`Game started. Good luck, ${hero.name}.`); 
}
init();

/* =========================
    NAME UI helpers
    ========================= */
function setNameFromInput(){
  const el = document.getElementById('nameInput');
  let val = (el.value || '').trim();
  
  if (!val) {
    log("Please choose a name.");
    return; 
  }
  
  if (hero.name !== val){
      hero.name = val;
      recalcDerived();
      updateUI(); // Isso chamará toggleNameInput(false)
      saveGame(); 
      log(`Name set to ${hero.name}`);
  }
  el.value = '';
}

/* =========================
    UI helpers + misc
    ========================= */
function openShopPrompt(){
  log("Shop is open on the left. Click Buy to purchase items.");
}

</script>
</body>
</html>